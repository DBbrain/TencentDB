# 四、数据库基础原理知识

在正式进入云数据库之前，我们先来补充一些数据库的基础知识，对其工作原理等能有一个基本认识，包括存储引擎主要功能及工作原理，常见DBMS系统基本功能要求，常见的几种分布式DBMS架构等。接下来我们会以MySQL为例，再去详细介绍一下MySQL基础知识，包括MySQL基础架构、日志系统、事务隔离、锁、索引、接口等。了解了这些之后，我们就可以很轻松地上手各大厂商的云数据库了。

## 1. 数据库存储引擎

关系型数据库中，存储的是海量的数据表和千丝万缕的关系表，在我们设计数据库之前都会关注一个问题——存储引擎，那么什么是存储引擎呢？

存储引擎是一种数据库底层软件组织，数据库管理系统可以使用存储引擎来创建、查询、删除和修改数据。面对如此多的数据表和关系表，数据存储的时候会以各种形态进行存储，因此面对不同数据类型的数据处理的方式也不同。拿mysql来说，他有很多种存储引擎，不同的存储引擎对于不同类型的数据处理方式、处理能力也不同，选择不同的存储引擎可以最大程度地让数据库得到利用，而mysql的核心就是存储引擎。mysql中常见的存储引擎有：MyISAM、InnoDB、MEMORY、MERGE和ARCHIVE，下面我们针对这些存储引擎来做一个了解。

在介绍存储引擎之前，我们先对一下可能出现的专业术语做一个大概的了解：

<table>
    <tr>
        <th>名称</th>
        <th>释义</th>
    </tr>
    <tr>
        <td>存储限制</td>
        <td>可存储空间最大容量。举个例子就是冰箱的最大存储空间</td>
    </tr>
    <tr>
        <td>事务</td>
        <td>作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。
            举个例子，之前有个脑经急转弯，把大象放进冰箱需要几步，再把长颈鹿放进冰箱需要几步，我们来看把长颈鹿放进冰箱：<br/>
            step1:先把冰箱打开<br/>
            step2:把大象取出来<br/>
            step3:把长颈鹿放进去<br/>
            step4：把冰箱关上<br/>
            这一系列操作就叫做事务，且每个环节都是必须的，试想如果冰箱只够放下一个大象，如果进行前两步，长颈鹿就放不进去。通过这个例子我们也能衍生出事务的四个特性（ACID特性）：<br/>
            A：原子性（Atomicity）
                事务中的操作要么都不做，要么就全做。<br/>
            C：一致性（Consistency）
                事务执行的结果必须是从数据库从一个一致性状态转换到另一个一致性状态。<br/>
            I：隔离性（Isolation）
                一个事务的执行不能被其他事务干扰<br/>
            D：持久性（Durability）
                一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</td>
    </tr>
    <tr>
        <td>索引</td>
        <td>在mysql中也叫做“键”，他的本质是一种数据结构，存储引擎可通过索引快速找到相关数据。举个例子我们看一本书的时候，想要快速找到我们想要的内容，一般都会去看他的目录，快速找到页码，这个目录就可以理解为一种索引。在mysql中，不同的索引类型针对不同的表结构，可以大大提高查询速度，下面我们看一下常用的集中索引类型：
            * B-Tree索引：简而言之就是我们熟知的树结构，实际上很多存储引擎使用的是B+tree的模式，即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。
            * 哈希索引：存储引擎对所有的索引列计算出一个哈希码，将哈希码存储在索引中，同时哈希表中保存每个数据行的指针，即存的是hash值和对应的行数。举个例子：一张表里第一列为姓名，第二列为年龄，第一列的每个姓名都会由hash函数生成一个索引值，比如我们要查找一个名叫“张三”的年龄，首先会先把“张三”转为对应的hash值，然后根据hash值找到第一列对应的行，即可得到相应的年龄
            * R-tree:也称为空间索引，无前缀查询，可以用作地理数据存储
            * 全文索引：类似于搜索引擎，通过查找文本中的关键词来搜索</td>
    </tr>
    <tr>
        <td>缓存</td>
        <td>引入数据缓存可以提高性能，数据一份存在数据库中，一份存在缓存中。比如查询数据的时候我不需要每次都去数据库里查询，近期的请求可以直接通过缓存查询很大的提高了性能</td>
    </tr>
    <tr>
        <td>主键</td>
        <td>唯一标识一条记录，不能有重复的，不允许为空，比如我们每个人的身份证号</td>
    </tr>
    <tr>
        <td>外键</td>
        <td>表的外键是另一表的主键, 外键可以有重复的, 可以是空值，比如公司存的个人信息表中的身份证号，在公司信息表中因为身份证号是我们自己个人信息表的主键，在公司信息表里就叫外键</td>
    </tr>
</table>

### 1.1）MyISAM

在mysql5.1及之前的版本，MyISAM是mysql的默认存储引擎。它提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，且崩溃后无法安全恢复。MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。MyISAM是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度。

### 1.2）InnoDB

是mysql的默认事务型引擎，也是最重要和使用最广泛的存储引擎。InnoDB的性能与自动崩溃恢复的特性，使得它在非事务存储需求中也很流行。

以上两种存储引擎是最常见的两种存储引擎，下面我们对比一下这两种存储引擎有什么区别：

<table>
    <tr>
        <th></th>
        <th>MyISAM</th>
        <th>InnoDB</th>
    </tr>
    <tr>
        <td>存储结构</td>
        <td>存储成三个文件：表定义文件、数据文件、索引文件。</td>
        <td>所有的表都放在同一个数据文件中</td>
    </tr>
    <tr>
        <td>存储空间</td>
        <td>支持三种存储格式：静态表、动态表、压缩表。针对占用空间大，不会再修改的表可以采用压缩表，能极大的节省占用空间</td>
        <td>需要更多的内存和存储，因为要建立缓冲池来提高索引性能</td>
    </tr>
    <tr>
        <td>事务支持</td>
        <td>无事务支持能力，崩溃后无法安全恢复</td>
        <td>具有事务、回滚和崩溃修复能力</td>
    </tr>
    <tr>
        <td>锁</td>
        <td>只支持表级锁</td>
        <td>支持事务和行级锁</td>
    </tr>
    <tr>
        <td>全文索引</td>
        <td>支持全文索引</td>
        <td>不支持全文索引</td>
    </tr>
    <tr>
        <td>外键</td>
        <td>不支持</td>
        <td>支持</td>
    </tr>
</table>

**总的来说在选型时，可以遵循以下几点：**
* **如果需要具有事务、回滚和崩溃修复的能力，选InnoDB；**
* **如果操作几乎都是读操作，可以选择MyISAM，有读有写交替频繁选InnoDB。**

还有几种常见的存储引擎，如MEMORY，这种存储引擎会把所有的数据都存在内存中，如果需要快速查询访问数据的话，可以选择这种存储引擎，但是又一个缺点是重启会有数据丢失；MERGE存储引擎是MyISAM的一个变种，是由多个MyISAM合并的虚拟表；ARCHIVE存储引擎只支持INSERT和SELECT操作等等还有诸多其他引擎。

## 2. DBMS系统

有了数据库之后，我们怎么对其进行维护和管理呢，这就是DBMS系统，中文名也叫数据库管理系统，用户和管理员都可以通过DBMS对数据库进行一系列操作和维护，以保证数据库的安全性和完整性。每个云服务商和数据库厂商都会提供这样的软件来协助用户管理数据库，在设计DBMS系统的时候，主要关注以下性能指标：

* **数据定义**：提供数据定义语言，供用户定义数据库的三级模式结构、两级映像以及完整性约束和保密限制等约束。
* **数据操作**：提供数据操作语言来帮助用户实现增删改查操作
* **数据库的运行管理**：包括多用户环境下的并发控制、安全性检查和存取限制控制、完整性检查和执行、运行日志的组织管理、事务的管理和自动恢复，即保证事务的原子性。
* **数据组织、存储和管理**：DBMS要分类组织、存储和管理各种数据，包括数据字典、用户数据、存取路径等，需确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。
* **数据库的保护**：DBMS对数据库的保护通过4个方面来实现：数据库的恢复、数据库的并发控制、数据库的完整性控制、数据库安全性控制。
* **数据库的维护**：包括数据库的数据载入、转换、转储、数据库的重组合重构以及性能监控等功能
* **通信**：与操作系统的联机处理、分时系统及远程作业输入的相关接口，负责处理数据的传送。

## 3. 锁

数据库中有个很重要的概念就是锁，他是一种机制，当多个用户同时对数据库进行访问操作的话，会带来数据库不一致的问题，而锁的存在就是为了保障数据库数据一致性和完整性。举个例子来理解，在商场中会出现多个消费者使用同一个试衣间的情况，当一个试衣间被一个消费者占用的时候，里面的消费者会把锁锁上，等试完了，打开锁，下一位消费者才可以进入。

锁的类型从操作类型上来看可以分为读锁和写锁，读锁是可以共享的也称为共享锁，当多个用户同时读取一份数据，不对数据有改动，读取的过程是互不干扰的；写锁也成排他锁，当一个试衣间关闭之后其他消费者就无法加入，写锁会阻塞所有的读锁和写锁。

为了最大程度的提高资源利用度，锁的粒度不同，针对不同的操作，尽可能地降低锁的粒度，可以最大程度地利用资源。通常情况下，锁的粒度可以分为：表级锁、页级锁、行级锁。这三种锁的特性大致可以归纳如下：

* **表级锁**：开销最小，会锁定整张表，加锁快，不会出现死锁的情况，写锁的优先级高于读锁。但是锁定粒度大会发生锁冲突的概率也更高，并发性较低。
* **行级锁**：开销量大，锁定粒度较小，加锁慢，会出现死锁的情况。但是可以最大程度地支持并发性，并发性较高。
* **页级锁**：开销量、锁定粒度介于表级锁和行级锁之间，会出现死锁的情况。并发性一般

## 4. 备份

数据备份是容灾的基础，防止因为出行误操作或系统故障引起数据丢失，将数据存储到存储介质中的一个过程。根据备份的方法，可以分为冷备和温备：

* **冷备**：简单来说就是离线备份，在数据库正常关闭时，将关键性数据备份到另一个位置的方法，对于备份数据库而言，冷备份是最快和最安全的方法，但是在冷备的过程中数据库必须是关闭状态。
* **热备**：即在线备份数据，在数据库运行的状态下，通过sql语句进行备份，当数据库发生问题时，可以重新执行再备份。这种备份方式是快速的，但是容错率很低，如果备份不成功，所得的结果不可用于时间点的恢复。

## 5. 数据库复制方式

复制解决的问题的是让一个服务器的数据与其他服务器保持同步，主库的数据库可以同步复制到多个备库上，主库崩溃或不可用的时候，备库也可以快速替代主库。数据库的复制方式一般可以分为异步复制、全同步复制和半同步复制：

* **异步复制**：是MySQL默认的复制方式，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主库上已经提交的事务可能并没有传到从库上，如果此时，强行将从库提升为主库，可能导致新主库上的数据不完整。
* **全同步复制**：指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
* **半同步复制**：是介于全同步复制与全异步复制之间的一种，主库只需要等待至少一个从库节点收到并且 FlushBinlog 到 RelayLog 文件即可，主库不需要等待所有从库给主库反馈。同时，这里只是一个收到的反馈，而不是已经完全完成并且提交的反馈，如此，节省了很多时间。

## 6. 安全组

安全组可以理解为一种防火墙，其包含过滤功能，用于设置单台或多台云数据库的网络访问限制。安全组是一个逻辑上的分组，用户可以将同一地域内具有相同网络安全隔离需求的云数据库实例加到同一个安全组内。云数据库与云服务器等共享安全组列表，安全组内基于规则匹配。

安全组的规则基于以下几点：
* **来源**：源数据（入站）或目标数据（出站）的 IP。
* **协议类型和协议端口**：协议类型如 TCP、UDP、HTTP 等。
* **策略**：允许或拒绝。

一个安全组可以包含多个安全规则，那么多种安全规则的优先级是怎么样：

* 安全组内规则具有优先级。规则优先级通过规则在列表中的位置来表示，列表顶端规则优先级最高，最先应用；列表底端规则优先级最低。
* 若有规则冲突，则默认应用位置更前的规则。

当有流量入/出绑定某安全组的实例时，将从安全组规则列表顶端的规则开始逐条匹配至最后一条。如果匹配某一条规则成功，允许通过，则不再匹配该规则之后的规则。